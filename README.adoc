= Evolutionary Architecture
Maciej "MJ" Jedrzejewski; Kamil Baczek
:toc:

++++
<div align="center">
  <picture>
    <source srcset="Assets/ea_banner_dark.png" media="(prefers-color-scheme: dark)">
    <source srcset="Assets/ea_banner_light.png" media="(prefers-color-scheme: light)">
    <img src="Assets/ea_banner_light.png" width="350" height="350" alt="ea banner">
  </picture>
</div>
++++

image:https://img.shields.io/github/v/release/evolutionary-architecture/evolutionary-architecture-by-example[realease, alt="realease"]

image:https://img.shields.io/github/license/evolutionary-architecture/evolutionary-architecture-by-example[GitHub license, alt="License Badge"]
image:https://img.shields.io/github/stars/evolutionary-architecture/evolutionary-architecture-by-example[GitHub stars, alt="Stars Badge"]
image:https://img.shields.io/github/commit-activity/m/evolutionary-architecture/evolutionary-architecture-by-example[GitHub commits, alt="Commits Badge"]
image:https://img.shields.io/github/last-commit/evolutionary-architecture/evolutionary-architecture-by-example[GitHub last commit, alt="Last Commit Badge"]
image:https://img.shields.io/github/issues/evolutionary-architecture/evolutionary-architecture-by-example[GitHub issues, alt="Issues Badge"]
image:https://img.shields.io/github/issues-pr/evolutionary-architecture/evolutionary-architecture-by-example[GitHub pull requests, alt="Pull Requests Badge"]
image:https://img.shields.io/github/forks/evolutionary-architecture/evolutionary-architecture-by-example[GitHub forks, alt="Forks Badge"]
image:https://img.shields.io/github/watchers/evolutionary-architecture/evolutionary-architecture-by-example[GitHub watchers, alt="Watchers Badge"]
image:https://img.shields.io/discord/1140287971367600148[alt="Discord Active"]



== Objective

=== Problem
When searching for guidance on .NET solution architecture, you will find countless repositories and resources. Each tends to focus exclusively on their preferred approach, whether it is:

- Clean, Onion or Hexagonal architecture
- Tactical Domain-Driven Design
- Modular monolith
- Microserverices

The real challenge? Most materials present their chosen approach as the universal solution, overlooking the nuanced reality of day-to-day software development. What is missing is a clear decision map to help you understand when and how to combine these different architectural elements and patterns.

The examples you do find often fall into two extremes: oversimplified demos that don't reflect real-world complexity, or overwhelming enterprise-scale applications that are difficult to learn from. Even worse, some resources inadvertently perpetuate misconceptions by conflating different architectural concepts.

We've all heard the phrase "it depends" so often it's become a cliché. Yes, every decision depends on context-but that doesn't mean we can't develop heuristics to guide our choices.

This repository offers something different: not just another static collection of patterns, but an evolutionary journey through the software architecture decision-making process. Here you will learn how to evaluate tradeoffs, combine approaches, and craft solutions that meet your specific needs at any given time.

Your journey to architectural clarity begins here.

=== Proposed Solution
Our approach unfolds like a story across four chapters, each building upon the last:

link:/Chapter-1-initial-architecture/README.adoc[**Chapter 1:** Initial Architecture: Focus On Simplicity]

Start with the basics: a production-ready foundation that separates modules with namespaces and leverages communication with an in-memory queue. Single production project with all the code inside.

link:/Chapter-2-modules-separation/README.adoc[**Chapter 2:** Modules Separation: Focus On Maintainability]

Develop the structure by organizing modules into separate projects. Multiple production projects that communicate with each other using an in-memory queue and events.

link:/Chapter-3-microservice-extraction/README.adoc[**Chapter 3:** Microservice Extraction: Focus On Growth]

Transform the selected module into an independent microservice, introducing an external message queue component (RabbitMQ) for inter-service communication. Code divided into multiple solutions representing modular monolith, microservice, and Nuget package.

link:/Chapter-4-applying-tactical-domain-driven-design/README.adoc[**Chapter 4:** Applying Tactical Domain-Driven Design: Focus On Complexity]

Leverage the power of tactical Domain-Driven Design concepts such as entities, value objects, aggregates, and domain events to manage the growing complexity of the extracted microservice.

The entire repostiory reflects years of real-world experience, including the lessons we learned the hard way. Our goal is to guide you toward architecture that grows with your needs – neither too simplistic to scale nor too complex to maintain.

What we cover:

- Analysis of a representative business domain (Fitness)
- Domain-Driven Design (strategic and tactical)
- Architectural patterns selection and evolution
- Hybrid architecture combining modular monolith and microservices
- Loose coupling
- .NET backend implementation with minimal API
- Architecture decision log
- Clean coding practices

What we leave to you:

- Frontend technology choice (React, Vue, Angular, Svelte, etc.)
- Logging implementation (we recommend https://serilog.net/[Serilog])
- Contract testing (we suggest https://github.com/pact-foundation/pact-net[Pact Net])

Each chapter includes static code analysis to maintain code quality – a practice we strongly recommend for production environments.

NOTE: These chapters represent several proven patterns and practices, but they are not hard and fast rules. Choose the approaches that meet your specific needs, or combine them to create the solution that fits your context. Think of this as your architectural compass, ready when you need it.

== Domain

=== Overview
It is time to look at our domain. We have chosen a fitness domain as our example – one that seems familiar at first glance. Most people recognize the basic flow:

- Getting membership offers
- Preparing and signing contracts
- Getting access passes
- Attending fitness classes

But this surface-level familiarity can be deceptive.

However, to identify the above processes, you usually need to analyze the domain with domain experts and break it down into smaller pieces called subdomains. Otherwise, there is a high risk of falling into a big ball of mud (or distributed mud) where everything is tightly coupled.

NOTE: The traditional domain expert is often pictured as a business representative – someone who lives and breathes the business processes every day. But don't overlook another crucial source of domain expertise: your developers, especially those who have been in the trenches with legacy systems. **Think about it:** developers working with legacy code must understand not just how the system works, but why it works that way. They have seen the edge cases, handled the exceptions, and often know which business rules are truly critical versus which ones are historical artifacts.

What appears to be a straightforward domain actually conceals layers of complexity:

- Pass expiration and renewal workflows
- Sophisticated discount strategies
- VIP member privileges
- Access control and rejection handling
- Membership status transitions

While we won't model every aspect of a fitness studio's operations (that would be a year-long endeavor!), we will demonstrate something more valuable: how to identify and separate key subdomains, and how to build extensible components that can grow with your needs. We have carefully chosen examples that are complex enough to illustrate real-world challenges while remaining manageable and instructive.

Ultimately, you should be able to apply similar techniques to your own complex domains, regardless of industry.

=== Subdomains
Every complex business domain becomes more manageable when broken down into smaller pieces. In domain modeling, we call these pieces _Subdomains_. Each subdomain represents a cohesive part of the domain. 

image::Assets/subdomains_theory.png[]

But how do we identify them?

While there are several effective approaches to domain decomposition, we particularly value two powerful techniques:

- https://www.eventstorming.com[Event Storming]: A collaborative modeling method that helps discover domain events and processes
- https://domainstorytelling.org[Domain Storytelling]: A visual approach to understanding business processes through storytelling

Both techniques help reveal the natural boundaries in your system by focusing on business flows and interactions. We won't focus on the details of either here, just the results you can achieve.

After careful analysis, we have identified the following subdomains that represent fitness domain:

image::Assets/subdomains.png[]

NOTE: Watch out! You might have noticed we used simple names like _Pass, Offer,_ and _Contract_ for our subdomains. While these work for our example, they could lead you down the wrong path in real projects. These entity-like names can limit your thinking about what a subdomain represents. Instead, think in terms of business capabilities and processes. For example, instead of _Passes_, consider _Passes Registration_; rather than _Offers_, use _Offers Management_. This process-oriented naming becomes especially valuable when your domain grows. You might need to split a subdomain into more specific business processes – for instance, breaking _Offers Management_ into _Offer Publishing_ and _Offer Advertising_. 

While there are many processes in each of the subdomains, we have chosen specific workflows to keep our example focused and meaningful:

image::Assets/subdomains_processes.png[]

Here is where things get interesting: these six processes across four subdomains initially appear independent. However, this isolation represents a common architectural pitfall in real-world applications. To make our example more realistic and instructive, we need to address how these subdomains communicate with each other.

image::Assets//subdomains_communication.png[]

Our fitness studio system comes alive through two key interactions:

- First, when you sign a contract, the system automatically registers your access pass
- Second, when your membership nears expiration, it triggers the creation of an  offer

These workflows demonstrate how our seemingly separate subdomains need to work together in real-world scenarios.

Now we need to somehow transform our subdomains into a technical solution. It is time to focus on bounded contexts.

=== Bounded contexts
To represent subdomains in your technical solution, you need a model. Often, we decide to just create a single, unified model for the entire solution. Unfortunately, this leads in future to a lot of issues because every subdomain operates in its own, and unique context.

Let us explain.

Imagine having two subdomains of _Workout Programming_ and _Meal Planning_ and each operate with the _Set_ term. However, it has very different meanings in each context:

- In _Workout Programming_, a it refers to a specific number of exercise repetitions (like "3 sets of 10 pushups")
- In _Meal Planning_, it means a predefined collection of meals (like "the basic meal set includes breakfast, lunch, and two snacks")

Using a single model across different subdomains forces your code to constantly check its context before applying business logic. This inevitable path leads to what developers jokingly call "ifology" - a maze of nested if-statements spreading throughout your codebase. Soon enough, what started as a simple intent to reuse code transforms into the dreaded "big ball of mud" or "spaghetti code" - where business rules become so intertwined that making even small changes becomes risky and time-consuming.

Another approach is to divide your system into multiple models. Each model will represent its ubiquitous language, business capabilities, and rules. This approach allows models to be extended independently without affecting the others. This way each model becomes a separate bounded context.

IMPORTANT: Don't be misled by the word "ubiquitous" in "ubiquitous language" - it is a common trap that catches many development teams. It is only universal (ubiquitous) within its specific bounded context, not across your entire system. 

While working on software systems, you will usually face one of the following cases:

- Multiple subdomains are represented by a single bounded context
- Each subdomain is represented by a single bounded context

In our implementation, we have made a deliberate architectural choice: each subdomain operates as its own bounded context, establishing clear boundaries and independence. However, it is important to note that real-world domains aren't always this neat. Sometimes multiple subdomains naturally group together into a single bounded context. Take, for example, how _Progress Tracking_, and _Virtual Coaching_ might naturally combine into a "Personalized Training" bounded context.

One of the really useful tools while working on the definition of bounded contexts is https://github.com/ddd-crew/bounded-context-canvas[Bounded Context Canvas] from DDD Crew.

When you are finished defining all the bounded contexts, you should define the communication and integration map between them. You can use a _Context Map_ to do this, but we will not focus on explaining it here.

=== Potential Patterns
Before you decide to start coding, it is worth to look at your analysis and division one more time and check the complexity of each (it will be mainly defined by the amount of processes and its business rules/policies). Let's take a look at below examples.

==== Passes

image::Assets/subdomain_passes_logic.jpg[]

There is no business logic:

- in the pass registration process, it is only informed that the contract has been signed
- In the pass expiry process, it is only informed that the pass expiry date has been reached.

In addition, the potential for new business rules to be applied to the above processes or other actions is rather low. As it looks like a perfect candidate for CRUD operations, we want to mark it as a candidate to become an _Active Record_ pattern.

NOTE: _Active Record_ is an pattern that rationalises the persistence layer in an application. It encapsulates the idea that a database record is an object in the application, with properties that map to the columns of the database table and the behaviour (domain logic) of that object.

==== Offers

image::Assets/subdomain_offers_logic.jpg[]

The story here is similar to _Passes_. There is no business logic, only the fact that the pass is expiring.

==== Contracts

image::Assets//subdomain_contracts_logic.jpg[]

This is the place where the fun begins. There are 3 business rules:

- in the process of contract preparation, it is only allowed if the customer is an adult AND smaller than the maximum height allowed (210 cm)
- in the contract signing process, it is only allowed if it is signed within 30 days of the contract being created, otherwise the contract has to be created from scratch

In addition, the potential for new business rules being applied to the above processes or other actions is quite high. Here the warning bell should go off - this has a really high potential to become more and more complex, so it might be a good candidate for a _Domain Model_.

NOTE: _Domain Model_ is a widely used pattern in software engineering that encapsulates the concepts and behaviours of a particular problem domain. This representation is designed to mimic the structure and functionality of the real-world system. The domain model pattern is particularly well known for its ability to handle complex business logic by providing a rich, object-oriented representation of the problem domain.

==== Reports

image::Assets/subdomain_reports.jpg[]

This case is really simple. The only thing that we want to achieve is to get the information about new passes that have been registered in each month. 

There is no business logic and there is also no need to have an object representation of the data retrieved. This is a perfect candidate for a _Transaction Script_.

NOTE: _Transaction Script_ is a pattern commonly used in software engineering that organises business logic into procedures, where each procedure handles a single request from the presentation. Each transaction script is a series of procedural steps that represent a sequence of tasks performed as part of a transaction, similar to a script in a play.

==== Summary

After deeper thinking about our subdomains, we decided for following patterns that will be applied in one of 4 chapters:

image::Assets/subdomains_architectural_patterns.jpg[]

== Chapters

In the beginning of every greenfield project we need to make a lot of decisions and we lack of knowledge. It is called _The Project Paradox_:

image::Assets/project_paradox.png[]

Quite often we are biased by conferences, meetups, friends and colleagues. As a result we decide for too complex architecture. 

This means starting with:

- microservices (where we do not yet know the traffic, scale and other factors)
- orchestrators
- data streaming
- NoSQL
- cache

and many more. In the end, we have a lot of problems of our own making, and the barrier to entry for any team member is extremely high. In fact, after release, we do not know if we need this or that block. We are also not optimised from a cost perspective and it is very difficult to find bottlenecks.

Another problem is choosing an architecture that is too trivial for too long (this happens less often than "overcomplicated"). This means that we just add code to a monolith, new features flood our codebase and then it becomes a big ball of mud.

What we want to show you in our story is the evolutionary approach that will tackle most of the applications you work with.

=== Chapter 1: Initial Architecture: Focus On Simplicity

In this chapter we will show you how to start your solution architecture. We start with modularisation from day one of the application, but modules are only separated by namespaces (there is only one project for the production code called `Fitnet`). Each process that occurs in each module is sliced vertically - all the code is covered in each process namespace. This gives us several advantages:

- better productivity - when we start a new design, we are not distracted by creating namespaces, renaming, moving things around
- all the code for each process is in just one namespace, so there is no need to look around in folders like `Controllers, Entities, Commands, Queries` etc. Everything is just in e.g. `SignContract`
- deleting or extracting the process is simple - you just drop or extract a namespace

Modules communicate with the in-memory queue.

==== https://s.icepanel.io/vY0SkvgDs7V83U/wOj3[Interactive diagram]
image::Assets/ice_panel_black.png[link="https://s.icepanel.io/vY0SkvgDs7V83U/wOj3",width=100,height=28]

=== Chapter 2: Modules Separation: Focus On Maintainability

This chapter focuses on the second step you can take in your application. After some time, you will find that your assumptions about modules were wrong - they grow fast, the business logic becomes more complex. You may have to decide to use a different type of database (e.g. key-value). Or the other way around - something you thought was going to be complex is actually quite simple and there is not a lot of business logic involved. Also, the team has grown and it is quite difficult to work on one project - lots of conflict and merging hell.

With this in mind, you can now start thinking to split your single `Fitnet` project into several ones:

- for one module it will be just `Fitnet.Reports` - there is only a transaction script, no business logic
- for another, it will be `Fitnet.Passes.Api, Fitnet.Passes.DataAccess` to build around the active record
- for the complex one it will be `Fitnet.Contracts.Api, Fitnet.Contracts.Application, Fitnet.Contracts.Core, Fitnet.Contracts.Infrastructure`

and so on. The modules still communicate with the in-memory queue (alternatives described in the chapter's own README).

=== Chapter 3: Microservice Extraction: Focus On Growth

Over time, you may need to extract a microservice from one of your application modules. In this chapter, you will identify the most common disintegrators (decision drivers for extracting a microservice). 

We will also add a message queue component to replace the in-memory queue. This way, we will improve the exchange of messages between the modules themselves and the microservice.

Here you will learn about various concepts that are important from a microservices architecture perspective.

==== https://s.icepanel.io/EPX45vmGXfBpnJ/cBSP[Interactive diagram]
image::Assets/ice_panel_black.png[link="https://s.icepanel.io/EPX45vmGXfBpnJ/cBSP",width=100,height=28]

=== Chapter 4: Applying Tactical Domain-Driven Design: Focus On Complexity

At the end of the story, we want to show you that it is possible to evolve to a domain model for one of your modules at some point.

You do not have to start from scratch if you do not know your business domain. And you do not need to apply all the concepts of Domain-Driven Design to get good results. 

Interesting fact - if you have done a proper analysis of your business domain in the beginning and have already broken it down into different subdomains (and combined them into e.g. a module), then you are almost done from a strategic Domain-Driven Design perspective. Now you just need to make some adjustments and do some tactical DDD. Cool? Absolutely cool!

Here we focus mainly on tactical DDD and describe

- value objects
- entities
- aggregates

You will also find some tips for the next steps.

== Repository Structure

=== Overview

We are trying to keep this repository as simple as possible, so that you can read it like a book. It contains chapters, where each chapter is an extension of the previous one, read like a story.

=== How To Navigate?

In the root folder of this repository you will find only this README, the assets (images & diagrams) used in it, and 4 folders containing the content for each chapter.

In each folder you will find the same root solution, but expanded:

1. Chapter 1 - Initial state of the application
2. Chapter 2 - Extraction into separate projects
3. Chapter 3 - Extracting a module to a microservice and using the message queue
4. Chapter 4 - Applying Tactical Domain-Driven Design to one of the modules

Another important thing to note is that the detailed description of each chapter is in its own README folder. There you will find the information on how to run the solution, what solution structure is used, and other important things that are only relevant to that particular chapter. 

We are not repeating the information covered in the previous chapter, we are just extending it with the decision we have made.

IMPORTANT: If you want to get the most out of this repository, we recommend that you read the first chapter, understand the code and description, and then navigate to another folder. Of course you can go through the folders in your own way but you might miss some concepts.

== Libraries and Platforms Used

The entire application is developed using C# and .NET 8.

In each chapter we use libraries and platforms that simplify the development process (no need to create them yourself). We try to keep it to a minimum. The certain disadvantage is that we do not have full control over it (trade-off we accept). Here is the list of the most important ones:

Application:

- https://www.docker.com[Docker]
- https://docs.fluentvalidation.net/en/latest/[Fluent Validation]
- https://github.com/jbogard/MediatR[MediatR]
- https://github.com/DapperLib/Dapper[Dapper]
- https://github.com/dotnet/efcore[Entity Framework]
- https://github.com/npgsql/npgsql[Npgsql]
- https://github.com/SonarSource/sonar-dotnet[SonarAnalyzer]

Testing:

- https://github.com/xunit/xunit[xunit]
- https://nsubstitute.github.io/[NSubstitute]
- https://github.com/VerifyTests/Verify[Verify]
- https://github.com/bchavez/Bogus[Bogus]
- https://github.com/fluentassertions/fluentassertions[Fluent Assertions]
- https://dotnet.testcontainers.org[Test Containers]

== Videos 🎥

You can learn the essentials of Evolutionary Architecture from these videos:

=== Webinar from Architecture Weekly 🇬🇧

In this webinar, Maciej "MJ" Jedrzejewski gives a detailed talk on Evolutionary Architecture. You can watch the recorded webinar link:https://www.architecture-weekly.com/p/webinar-11-maciej-mj-jedrzejewski[here].

=== Presentation at Programistok 2023 Conference 🇵🇱

This is a recorded presentation from the Programistok 2023 Conference, where Evolutionary Architecture was extensively explained. You can watch it on YouTube link:https://www.youtube.com/watch?v=tfCtM8D_DZ4&t=598s[here].

=== Evolutionary Architecture Visualized Through NDepend 🇬🇧

Explore Evolutionary Architecture visualized through NDepend, featuring comprehensive dependency and code analysis in the form of an interview led by Ferry de Boer with Kamil. Watch it on YouTube link:https://www.youtube.com/watch?v=Z60SAiVevIM&t[here].

== Authors ✍️

[cols=2*,options=header]
|===
|Maciej Jedrzejewski
|Kamil Baczek

|Software architect, tech lead and facilitator of modern software development practices that allow shortening the feedback loop in every area of a lifecycle e.g. trunk-based development, short-living branches, vertical slices, canary releases, CI/CD, and more.

https://meaboutsoftware.com/[Blog]
https://www.linkedin.com/in/jedrzejewski-maciej/[Linkedin]
https://www.youtube.com/@meaboutsoftware[YouTube]

|.NET Engineer, Software Architect who empowers teams to build better software through solid software architecture, utilising techniques such as Event Storming, Domain Driven Design and various architecture styles and design patterns.

https://artofsoftwaredesign.net/[Blog]
https://www.linkedin.com/in/kamilbaczek/[Linkedin]
https://github.com/kamilbaczek[Github]
|===

== 👩‍💻👨‍💻 What Software Engeeniers Say

=== 👨‍💼 Chief Software Architect
____
Really appreciate the repository and the content you are sharing. I think it is really valuable to see the evolutionary approach in practice, and focus on simplicity and pragmatic reasoning and making decisions in software design.
____

=== 👨‍💻 .NET Developer
____
Your work has been super helpful as I dive deeper into this field. Evolutionary Architecture, in particular, is incredible and has really clicked for me thanks to your examples and insights.
____

=== 👨‍💻 .NET Developer
____
I was always concerned about what architecture to use on a project. Sometimes, spending time on researching what's right affects my motivation. Your approach which focuses on creating a project with an architecture that evolves resonates perfectly with me. Your efforts in creating such a wonderful resource is greatly appreciated.
____


== 💬 Join our Community
Join the "Evolutionary Architecture Community" on Discord (https://discord.gg/BGxYkHFCCF) to engage with fellow architects and enthusiasts who share a fervor for pushing boundaries and crafting high-quality software systems. Whether you have questions, suggestions, or feedback for our repository, we're excited to hear from you and collaborate towards continuous improvement.

image::Assets/discord.png[link="https://discord.gg/BGxYkHFCCF",width=200,height=64]

== ⭐ Say thanks
Feel free to give a ⭐ to this repository if you like it. Your support is greatly appreciated!
