# Chapter 1: Initial Architecture - Focus On Simplicity

- [Case](#case)
  - [Overview](#overview)
  - [Requirements](#requirements)
  - [Main assumptions](#main-assumptions)
  - [Solution](#solution)
    - [Overview](#overview-1)
    - [Structure](#structure)
    - [Communication](#communication)
    - [Tests](#tests)
      - [Integration Tests](#integration-tests)
      - [Unit Tests](#unit-tests)
    - [Miscellaneous](#miscellaneous)
- [How to run?](#how-to-run)
  - [Requirements](#requirements-1)
  - [How to get .NET SDK?](#how-to-get-net-sdk)
  - [Run locally](#run-locally)
  - [How to run Integration Tests?](#how-to-run-integration-tests)

<div align="center">
  <picture>
    <source srcset="../Assets/ea_banner_dark.png" media="(prefers-color-scheme: dark)">
    <source srcset="../Assets/ea_banner_light.png" media="(prefers-color-scheme: light)">
    <img src="../Assets/ea_banner_light.png" width="350" height="350" alt="ea banner">
  </picture>
</div>

![Build Status](https://github.com/evolutionary-architecture/evolutionary-architecture-by-example/actions/workflows/chapter-1-workflow.yml/badge.svg)

[![Codecov](https://codecov.io/gh/evolutionary-architecture/evolutionary-architecture-by-example/branch/main/graph/badge.svg)](https://codecov.io/gh/evolutionary-architecture/evolutionary-architecture-by-example)

## Case

### Overview

When building a new application, we often get caught up in using the latest tech stack - jumping straight to advanced frameworks, complex architectures, and trendy tools. This creates unnecessary complexity from day one.

Here is the core problem: We make critical technical decisions at the exact moment (the beginning) when we understand the least about what we are building. Most of these early decisions turn out to be wrong, or at best, lucky guesses. By the time we realize our mistakes, the codebase is either too complex to change or it is too late.

This approach typically leads to one of two outcomes:

- A big ball of mud
- A big ball of distributed mud

The solution? Focus first on understanding the business requirements and build the simplest working solution possible.

At the start, we skip these complexities:

- Microservices
- Caching
- Aggregates
- Data streaming
- Heavy container orchestrators

Starting simple brings clear benefits:

- Decisions are made when you have enough knowledge to make them
- New developers can onboard quickly
- The team can master each component before adding more complexity
- The codebase stays maintainable and clean

This approach doesn't guarantee perfection, but it dramatically improves your chances of building something that is both useful and maintainable. And that is our way.

Let's get into the details!

> Always choose architecture based on **your current needs and context**. Not a wishful thinking.

### Requirements

A fitness studio we work with needed a simple membership management system. Here is what they asked for in their MVP:

- Create offers for customers (both new and existing)
- Prepare contracts when customers accept offers
- Enable contract signing by customers
- Automatically create customer passes after contract signing
- Send renewal offers when passes expire

They were clear about their approach: if the system proves valuable, they will invest in more features, and help us to get more customers. If not, they will cut their losses and try something else. This practical mindset helped us focus on delivering the core functionality first.

### Main assumptions

Even with market research, surveys, and customer feedback pointing to success, any new system is built on assumptions. We need to be realistic about what we don't know. We have the following key assumptions.

Initial scale and usage:

- Starting userbase: 500-5000 people
- European market only (minimal timezone complexity)
- Mix of operating hours (12h, 16h, and 24/7 facilities)

Traffic calculations:

- Average 100 requests per user per day
- With 5000 users: 500,000 daily requests
- Adding 25% safety margin: 625,000 daily requests
- Breaks down to about 7 requests per second (to simplify - it could only happen in a perfect world with the even distribution)

This relatively modest load means we can start with simple infrastructure - no need for complex systems yet.

**NOTE:** Each application has different characteristics. For instance, on social media platforms, users may generate an average of several thousand requests each, while in banking or intranet applications, it might be dozens or hundreds. In addition, in real-world applications, traffic is not evenly distributed. Your application needs to be able to handle spikes.

**NOTE:** Before you go live with the application, it is a good idea to see how it performs under heavy traffic. This will help you understand the limitations of your architecture. This is usually done against expected traffic (load tests) and spikes (stress tests). You can use any tool to do this. Our recommendation is [k6](https://k6.io/).

### Solution

#### Overview

During our business analysis, we identified several subdomains of the fitness domain. We decided to make each subdomain its own bounded context.

![](../Assets/subdomains.png)

We also decided to represent each bounded context by a separate module in our codebase. Of course, your bounded contexts aren't set in stone - they will evolve as your business does. As your company launches new services, restructures existing operations, or acquires other companies, you will likely need to adapt. This may mean adjusting or removing existing bounded contexts, or creating entirely new ones.

The next step is to define the structure of our solution.

#### Structure

After creating our solution, we split the code into just 3 projects:

- `Fitnet` (main production code)
- `Fitnet.IntegrationTests`
- `Fitnet.UnitTests`

![](Assets/projects_division.png)

Yes, you read that right - only 3 projects! While this might seem unconventional, it is worth considering for your greenfield application. Rather than splitting modules into separate projects, we organize them using namespaces. It is a different mindset, but one that offers significant benefits.

The main `Fitnet` project contains the entire production code responsible for:

- API to our application
- Business logic for our processes
- Data access

However, this isn't a classic technical layer split. Instead, we structure our code based on:

- Modules represented by namespaces - each bounded context gets its own module
- Data divided into database schemas (logical split), with each module having its own schema
- Business processes organized in vertical slices - all code needed for a specific process (like contract signing) lives in one folder

Looking at the contract signing process as an example, you will find these elements grouped together:

- Business rules
- Events
- Endpoints
- Request objects used by the endpoints

You can see how it looks like [here](https://github.com/evolutionary-architecture/evolutionary-architecture-by-example/tree/main/Chapter-1-initial-architecture/Src/Fitnet/Contracts/SignContract).

Some code is naturally shared within each module:

- Entities in the Data folder (reused across business processes)
- Database migrations and operations
- Module registrations for endpoints, database usage, and API paths

There is some [code](https://github.com/